# Frontend Implementation Plan

*Generated by Ralph during planning mode.*

## Status

- **State:** Planning Complete
- **Last Updated:** 2026-02-09

## Summary

The frontend for Forge needs to be built from scratch. The `src/frontend/` directory is currently empty. Based on the specifications in `specs/10-web-interface.md` and the SDK/API design in `specs/09-sdk-api.md`, we need to implement a brutalist industrial web interface for controlling and monitoring Forge's autonomous software engineering system.

**Note:** There is an existing `ralph/web-ui/` directory which appears to be a simple monitoring tool for the Ralph loop itself, NOT the Forge application frontend. The actual Forge frontend should be built in `src/frontend/`.

### Key Requirements from Specs:

1. **Design System:** Brutalist industrial design with Forge orange (#FF6B00) accent on carbon black (#0A0A0A)
2. **Typography:** Geist-Pixel for accents/headings, Geist Mono for everything else
3. **Views:** Dashboard, Captain Interview, Task Detail, Refinery, Artifacts Browser, Change Request
4. **Real-time:** NDJSON event stream, character-by-character streaming
5. **Emergency Controls:** Always-visible "Pause All" button

---

## Gap Analysis

### What Exists
- Empty `src/frontend/` directory (just `.gitkeep`)
- Separate `ralph/web-ui/` monitoring tool (for Ralph loop, not Forge)

### What's Needed (100% Missing)
- Project initialization (package.json, Vite config, TypeScript config)
- Design system and CSS tokens
- All views specified in 10-web-interface.md
- SDK client integration
- NDJSON event streaming
- WebSocket connection handling
- DAG visualization
- All UI components

---

## Completed Tasks

### Phase 1: Project Foundation (Critical Path)

#### 1.1 Initialize Frontend Project (Completed 2026-02-09)
- Initialized React+TypeScript project with Vite
- Configured ESLint, Tailwind, and Prettier rules
- Verified build and test scripts

#### 1.2 Implement Design System (Completed 2026-02-09)
- Defined brutalist color palette and CSS tokens
- Configured Geist Mono font
- Created atomic components: StatusLED, Button

#### 1.3 Create SDK Client Wrapper (Completed 2026-02-09)
- Implemented `ForgeClient` for all API endpoints
- Defined full TypeScript interfaces for Runs, Tasks, Events
- Added error handling and API response typing

#### 1.4 Implement Event Stream Handler (Completed 2026-02-09)
- Implemented `useEventStream` hook
- Added resilient NDJSON parsing with reconnection logic
- Added tests for streaming utilities

#### 2.2 Implement Status LED Component (Completed 2026-02-09)
- Improved `StatusLED` component with correct status colors and animations
- Added comprehensive unit tests
- Fixed accessibility and labeling issues

#### 2.3 Create DAG Visualization Component (Completed 2026-02-09)
- Implemented `DAGGraph` and `TaskNode` components using @xyflow/react
- Integrated `dagre` for automatic graph layout
- Added strict type safety matching spec schemas
- Implemented comprehensive unit tests for graph rendering and interaction
- Ensured responsiveness and status-based styling

#### 2.4 Create Task List Component (Completed 2026-02-10)
- Implemented sortable/filterable task list table
- Added status filtering and search functionality
- Implemented click navigation to task detail
- Added comprehensive unit tests for sorting, filtering, and interaction
- Ensured type safety and accessibility

### Phase 2: Core Components

#### 2.1 Create App Shell and Routing (Completed 2026-02-09)
- Set up React Router with routes for all main views
- Implemented persistent TopBar and Layout components
- Added "Pause All" button and status indicators
- Created placeholder views for Dashboard, Captain, Tasks, Refinery, Artifacts, Changes
- Added comprehensive tests for routing and shell components

---

## Prioritized Tasks

### Phase 2: Core Components

#### 2.1 Create App Shell and Routing (Completed 2026-02-09)
- Set up React Router with routes for all main views
- Implemented persistent TopBar and Layout components
- Added "Pause All" button and status indicators
- Created placeholder views for Dashboard, Captain, Tasks, Refinery, Artifacts, Changes
- Added comprehensive tests for routing and shell components

---

#### 2.4 Create Task List Component (Completed 2026-02-10)
- Implemented sortable/filterable task list table
- Added status filtering and search functionality
- Implemented click navigation to task detail
- Added comprehensive unit tests for sorting, filtering, and interaction
- Ensured type safety and accessibility

### Phase 3: Main Views

#### 3.1 Implement Dashboard/Run View (Completed 2026-02-10)
- Implemented `DashboardView` with grid layout
- Integrated `DAGGraph`, `TaskList`, `ActiveAgentsPanel`, and `EventsFeed`
- Created `EventsFeed` component with auto-scroll and filtering
- Created `ActiveAgentsPanel` with simulated agent logs
- Ensured responsiveness and mocked data integration
- Verified with comprehensive unit tests

### Phase 3: Main Views

#### 3.2 Implement Captain Interview View (Completed 2026-02-10)
- Implemented `CaptainChat` view with `MessageBubble`, `ToolCall`, and `PlanReview` components.
- Added message streaming simulation and thinking states.
- Implemented interactive chat input with auto-resize.
- Integrated mock plan generation and approval flow.
- Added comprehensive unit tests for all chat components and interactions.

#### 3.3 Implement Task Detail View (Completed 2026-02-10)
- Implemented `TaskDetailView` with real-time streaming updates.
- Created `TaskHeader` with metadata, status LED, and dependency links.
- Implemented `AgentOutputStream` with auto-scroll and lock.
- Created `ToolHistorySidebar` with collapsible tool calls (args, results, duration).
- Implemented `WalkthroughViewer` for completed tasks (frontmatter, risks, file changes).
- Integrated `useEventStream` for live updates via NDJSON.
- Added comprehensive unit tests for all components.

#### 3.4 Implement Refinery View
**Complexity:** Medium  
**Dependencies:** 2.1, 2.2, 1.4

Dedicated view for merge and integration monitoring.

**Acceptance Criteria:**
- Merge progress table showing:
  - Source branch
  - Target branch
  - Status LED
  - Merge strategy
- Conflict indicators:
  - Panel listing conflicting files
  - Resolution status per file
  - Visual urgency for unresolved
- Integration test results section
- Change Request emission banner
- Sub-agent spawning panel (shows spawned agents)
- Refinery progress timeline/log

**Required Tests:**
- Merge status updates in real-time
- Conflict files displayed correctly
- Test results render with pass/fail

---

#### 3.5 Implement Artifacts Browser View
**Complexity:** Medium  
**Dependencies:** 2.1, 1.3

File-explorer style view for browsing artifacts.

**Acceptance Criteria:**
- Left sidebar: collapsible file tree
  - Directories: specs/, tasks/, walkthroughs/, change-requests/
  - File type indicators
- Content pane:
  - Markdown files: rendered with syntax highlighting
  - YAML files: syntax highlighted
  - JSON files: syntax highlighted
  - `dag.json`: interactive graph view
- Clicking file loads content
- Clicking DAG nodes navigates to Task Detail

**Required Tests:**
- File tree renders artifact structure
- Content renders based on file type
- DAG interactive mode works

---

#### 3.6 Implement Change Request View
**Complexity:** Medium  
**Dependencies:** 2.1, 1.3

View for managing Change Requests.

**Acceptance Criteria:**
- CR list table:
  - Status LED (pending/approved/rejected/applied)
  - CR ID
  - Title
  - Source
  - Created timestamp
  - Impact summary
- Sortable and filterable
- CR detail panel:
  - Full CR markdown rendered
  - Impact assessment
  - DAG overlay diff visualization
- Approve/Reject controls (when applicable)
  - Approve: green button
  - Reject: red button + reason input
- Decision record display after action

**Required Tests:**
- CR list displays all CRs
- Detail panel shows correct content
- Approve/Reject buttons work
- Status updates after action

---

### Phase 4: Polish and Optimization

#### 4.1 Implement Virtual Scrolling
**Complexity:** Medium  
**Dependencies:** 3.1, 3.2, 3.3

Optimize long lists and streams with virtual scrolling.

**Acceptance Criteria:**
- Virtual scroll for agent output streams
- Virtual scroll for events feed
- DOM node count stays bounded (<500 nodes)
- Smooth scrolling experience
- Scroll-to-bottom functionality

**Required Tests:**
- Performance test with 10,000 events
- FPS stays above 30 during rapid updates
- Memory usage stays bounded

---

#### 4.2 Implement Accessibility Features
**Complexity:** Medium  
**Dependencies:** All views

Ensure accessibility compliance.

**Acceptance Criteria:**
- All interactive elements keyboard-navigable
- Status LEDs have text labels
- ARIA roles on dynamic regions
- `aria-live` for streaming output
- `role="status"` for status indicators
- Focus indicators: 2px solid `--accent` outline
- Skip-to-content link

**Required Tests:**
- Keyboard navigation through all views
- Screen reader announces status changes
- Focus visible on all interactive elements

---

#### 4.3 Add Responsive Design
**Complexity:** Small  
**Dependencies:** All views

Make interface usable on various screen sizes.

**Acceptance Criteria:**
- Breakpoints for tablet and mobile
- Collapsible panels on narrow screens
- Touch-friendly tap targets (min 44px)
- DAG visualization scales appropriately

**Required Tests:**
- Layout works at 1920px, 1280px, 768px widths
- All functionality accessible on tablet

---

#### 4.4 Performance Optimization
**Complexity:** Medium  
**Dependencies:** All views

Optimize rendering performance.

**Acceptance Criteria:**
- requestAnimationFrame batching for streaming updates
- Efficient event routing
- Lazy loading of non-critical components
- Code splitting per route
- Bundle size under 200KB gzipped (excluding fonts)

**Required Tests:**
- Lighthouse performance score > 80
- First contentful paint < 1.5s
- Time to interactive < 3s

---

## Completed Tasks

*Completed tasks will be moved here.*

---

## Blockers / Notes

### Backend API Dependency
- Frontend development can proceed with mock data
- Full integration requires backend API to be running
- NDJSON streaming endpoint is critical for real-time updates

### Font Loading
- Geist fonts need to be loaded from Vercel CDN or bundled locally
- Fallback stack: `"Geist Mono", "SF Mono", "Cascadia Code", "Fira Code", monospace`

### DAG Visualization Library
- Consider using D3.js, vis.js, or a lighter alternative like Dagre
- Performance critical for graphs with 100+ nodes

### Framework Decision (from spec)
- Framework not specified - candidates: React, Svelte, SolidJS, or vanilla TS
- Recommendation: **React** with TypeScript
  - Large ecosystem for DAG visualization
  - Good TypeBox integration
  - Mature virtual scrolling libraries (react-window, react-virtuoso)
  - Team likely familiar with React patterns

### Environment Variables
```
VITE_API_URL=http://localhost:3001
```

---

*When every task is finished, add a standalone line containing exactly `ALL TASKS COMPLETE` (nothing else on that line) to signal the loop to stop.*

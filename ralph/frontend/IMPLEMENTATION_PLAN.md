# Frontend Implementation Plan

*Generated by Ralph during planning mode.*

## Status

- **State:** Planning Complete
- **Last Updated:** 2026-02-09

## Summary

The frontend for Forge needs to be built from scratch. The `src/frontend/` directory is currently empty. Based on the specifications in `specs/10-web-interface.md` and the SDK/API design in `specs/09-sdk-api.md`, we need to implement a brutalist industrial web interface for controlling and monitoring Forge's autonomous software engineering system.

**Note:** There is an existing `ralph/web-ui/` directory which appears to be a simple monitoring tool for the Ralph loop itself, NOT the Forge application frontend. The actual Forge frontend should be built in `src/frontend/`.

### Key Requirements from Specs:

1. **Design System:** Brutalist industrial design with Forge orange (#FF6B00) accent on carbon black (#0A0A0A)
2. **Typography:** Geist-Pixel for accents/headings, Geist Mono for everything else
3. **Views:** Dashboard, Captain Interview, Task Detail, Refinery, Artifacts Browser, Change Request
4. **Real-time:** NDJSON event stream, character-by-character streaming
5. **Emergency Controls:** Always-visible "Pause All" button

---

## Gap Analysis

### What Exists
- Empty `src/frontend/` directory (just `.gitkeep`)
- Separate `ralph/web-ui/` monitoring tool (for Ralph loop, not Forge)

### What's Needed (100% Missing)
- Project initialization (package.json, Vite config, TypeScript config)
- Design system and CSS tokens
- All views specified in 10-web-interface.md
- SDK client integration
- NDJSON event streaming
- WebSocket connection handling
- DAG visualization
- All UI components

---

## Completed Tasks

### Phase 1: Project Foundation (Critical Path)

#### 1.1 Initialize Frontend Project (Completed 2026-02-09)
- Initialized React+TypeScript project with Vite
- Configured ESLint, Tailwind, and Prettier rules
- Verified build and test scripts

#### 1.2 Implement Design System (Completed 2026-02-09)
- Defined brutalist color palette and CSS tokens
- Configured Geist Mono font
- Created atomic components: StatusLED, Button

#### 1.3 Create SDK Client Wrapper (Completed 2026-02-09)
- Implemented `ForgeClient` for all API endpoints
- Defined full TypeScript interfaces for Runs, Tasks, Events
- Added error handling and API response typing

#### 1.4 Implement Event Stream Handler (Completed 2026-02-09)
- Implemented `useEventStream` hook
- Added resilient NDJSON parsing with reconnection logic
- Added tests for streaming utilities

### Phase 2: Core Components

#### 2.1 Create App Shell and Routing (Completed 2026-02-09)
- Set up React Router with routes for all main views
- Implemented persistent TopBar and Layout components
- Added "Pause All" button and status indicators
- Created placeholder views for Dashboard, Captain, Tasks, Refinery, Artifacts, Changes
- Added comprehensive tests for routing and shell components

---

## Prioritized Tasks

### Phase 2: Core Components

#### 2.1 Create App Shell and Routing (Completed 2026-02-09)
- Set up React Router with routes for all main views
- Implemented persistent TopBar and Layout components
- Added "Pause All" button and status indicators
- Created placeholder views for Dashboard, Captain, Tasks, Refinery, Artifacts, Changes
- Added comprehensive tests for routing and shell components

#### 2.2 Implement Status LED Component
**Complexity:** Small  
**Dependencies:** 1.2

Create reusable status LED indicator.

**Acceptance Criteria:**
- Status LED component (`<StatusLED status={...} />`)
- Supports all statuses: pending, running, done, failed, merged, stale
- Color mapping per spec:
  - Gray: pending/idle
  - Orange with pulse: running/active
  - Green: done/passed
  - Red: failed/blocked
  - Dim green: merged
  - Amber: stale/degraded
- 6px circular indicator (only permitted circular element)
- CSS pulse animation for running state

**Required Tests:**
- Renders correct color for each status
- Animation plays for running status
- Accessible (has text label, not color-only)

---

#### 2.3 Create DAG Visualization Component
**Complexity:** Large  
**Dependencies:** 1.2, 2.2

Implement the directed acyclic graph visualization for task dependencies.

**Acceptance Criteria:**
- DAG component renders nodes and edges from `dag.json` schema
- Node styling per status (colors from spec)
- Edges: 1px lines in `--border` color
- Selected task edges highlight in `--accent`
- Nodes are clickable (navigate to Task Detail View)
- Real-time updates as task statuses change
- Performance: handles 100+ nodes smoothly
- Pan/zoom controls for large graphs

**Required Tests:**
- Renders graph with correct node positions
- Node colors match status
- Clicking node triggers navigation
- Status changes update visualization

---

#### 2.4 Create Task List Component
**Complexity:** Medium  
**Dependencies:** 1.2, 2.2

Implement sortable/filterable task list table.

**Acceptance Criteria:**
- Monospace table with columns:
  - Status (LED)
  - ID
  - Title
  - Type
  - Agent
  - Branch
  - Dependencies count
- All columns sortable
- Filter by status (dropdown)
- Search by title
- Row click navigates to Task Detail View
- Active filters shown as dismissible pills

**Required Tests:**
- Sorting works for all columns
- Filter reduces displayed rows
- Search filters by title text
- Navigation works on row click

---

### Phase 3: Main Views

#### 3.1 Implement Dashboard/Run View
**Complexity:** Large  
**Dependencies:** 2.1, 2.3, 2.4, 1.4

The primary operational view showing DAG, task list, and active agents.

**Acceptance Criteria:**
- Layout: DAG panel + Task List + Active Agents Panel + Events Feed
- Active Agents Panel shows running agents with:
  - Status LED
  - Agent ID
  - Task name
  - Elapsed time
  - Last 2-3 lines of output (streaming)
- Events Feed: scrolling NDJSON events styled as terminal log
  - Auto-scroll unless user scrolled up
  - Filterable by event type
  - Max 500 rendered events
- Responsive layout

**Required Tests:**
- All panels render with data
- Agent output streams in real-time
- Events auto-scroll works
- Scroll lock on user scroll

---

#### 3.2 Implement Captain Interview View
**Complexity:** Large  
**Dependencies:** 2.1, 1.3, 1.4

Conversational interface for the Captain planning phase.

**Acceptance Criteria:**
- Chat pane layout (max 800px centered)
- User messages: right-aligned, `--bg-surface` background
- Captain messages: left-aligned, 2px orange left border
- Character-by-character streaming of Captain responses
- Tool usage display:
  - Collapsible panels inline with Captain text
  - Shows tool name + truncated command
  - Expandable to show full args and results
- Artifact creation indicators:
  - Prominent when Captain creates spec/task/DAG
  - Clickable â†’ opens Artifacts Browser
- Plan finalized banner
- Plan review section after Captain finishes:
  - List of created artifacts
  - Each expandable to show content
  - "Approve & Execute" button
  - Optional "Edit Plan" button
- Input area fixed at bottom
- Disabled while Captain is generating

**Required Tests:**
- Messages render in correct positions
- Streaming text appears character-by-character
- Tool panels collapse/expand
- Input disabled during generation
- Approve button triggers execution

---

#### 3.3 Implement Task Detail View
**Complexity:** Large  
**Dependencies:** 2.1, 2.2, 1.4

Detailed view for a single task.

**Acceptance Criteria:**
- Header with task metadata (status, ID, title, type, deps, branch, agent)
- Agent output stream:
  - Real-time character-by-character streaming
  - Thinking blocks styled differently (gray border)
  - Auto-scroll with scroll lock
  - Virtual scrolling for long outputs
- Tool call history sidebar:
  - Chronological list of all tool calls
  - Collapsible entries
  - Shows args, result, duration
  - Error calls highlighted red
- Walkthrough section (after completion):
  - Rendered markdown
  - YAML frontmatter fields as structured header
- Files changed list
- Test results summary (if tests run)
- Risks and Followups sections

**Required Tests:**
- Output streams in real-time
- Virtual scrolling works for 10,000+ lines
- Tool history is chronological
- Walkthrough renders after completion

---

#### 3.4 Implement Refinery View
**Complexity:** Medium  
**Dependencies:** 2.1, 2.2, 1.4

Dedicated view for merge and integration monitoring.

**Acceptance Criteria:**
- Merge progress table showing:
  - Source branch
  - Target branch
  - Status LED
  - Merge strategy
- Conflict indicators:
  - Panel listing conflicting files
  - Resolution status per file
  - Visual urgency for unresolved
- Integration test results section
- Change Request emission banner
- Sub-agent spawning panel (shows spawned agents)
- Refinery progress timeline/log

**Required Tests:**
- Merge status updates in real-time
- Conflict files displayed correctly
- Test results render with pass/fail

---

#### 3.5 Implement Artifacts Browser View
**Complexity:** Medium  
**Dependencies:** 2.1, 1.3

File-explorer style view for browsing artifacts.

**Acceptance Criteria:**
- Left sidebar: collapsible file tree
  - Directories: specs/, tasks/, walkthroughs/, change-requests/
  - File type indicators
- Content pane:
  - Markdown files: rendered with syntax highlighting
  - YAML files: syntax highlighted
  - JSON files: syntax highlighted
  - `dag.json`: interactive graph view
- Clicking file loads content
- Clicking DAG nodes navigates to Task Detail

**Required Tests:**
- File tree renders artifact structure
- Content renders based on file type
- DAG interactive mode works

---

#### 3.6 Implement Change Request View
**Complexity:** Medium  
**Dependencies:** 2.1, 1.3

View for managing Change Requests.

**Acceptance Criteria:**
- CR list table:
  - Status LED (pending/approved/rejected/applied)
  - CR ID
  - Title
  - Source
  - Created timestamp
  - Impact summary
- Sortable and filterable
- CR detail panel:
  - Full CR markdown rendered
  - Impact assessment
  - DAG overlay diff visualization
- Approve/Reject controls (when applicable)
  - Approve: green button
  - Reject: red button + reason input
- Decision record display after action

**Required Tests:**
- CR list displays all CRs
- Detail panel shows correct content
- Approve/Reject buttons work
- Status updates after action

---

### Phase 4: Polish and Optimization

#### 4.1 Implement Virtual Scrolling
**Complexity:** Medium  
**Dependencies:** 3.1, 3.2, 3.3

Optimize long lists and streams with virtual scrolling.

**Acceptance Criteria:**
- Virtual scroll for agent output streams
- Virtual scroll for events feed
- DOM node count stays bounded (<500 nodes)
- Smooth scrolling experience
- Scroll-to-bottom functionality

**Required Tests:**
- Performance test with 10,000 events
- FPS stays above 30 during rapid updates
- Memory usage stays bounded

---

#### 4.2 Implement Accessibility Features
**Complexity:** Medium  
**Dependencies:** All views

Ensure accessibility compliance.

**Acceptance Criteria:**
- All interactive elements keyboard-navigable
- Status LEDs have text labels
- ARIA roles on dynamic regions
- `aria-live` for streaming output
- `role="status"` for status indicators
- Focus indicators: 2px solid `--accent` outline
- Skip-to-content link

**Required Tests:**
- Keyboard navigation through all views
- Screen reader announces status changes
- Focus visible on all interactive elements

---

#### 4.3 Add Responsive Design
**Complexity:** Small  
**Dependencies:** All views

Make interface usable on various screen sizes.

**Acceptance Criteria:**
- Breakpoints for tablet and mobile
- Collapsible panels on narrow screens
- Touch-friendly tap targets (min 44px)
- DAG visualization scales appropriately

**Required Tests:**
- Layout works at 1920px, 1280px, 768px widths
- All functionality accessible on tablet

---

#### 4.4 Performance Optimization
**Complexity:** Medium  
**Dependencies:** All views

Optimize rendering performance.

**Acceptance Criteria:**
- requestAnimationFrame batching for streaming updates
- Efficient event routing
- Lazy loading of non-critical components
- Code splitting per route
- Bundle size under 200KB gzipped (excluding fonts)

**Required Tests:**
- Lighthouse performance score > 80
- First contentful paint < 1.5s
- Time to interactive < 3s

---

## Completed Tasks

*Completed tasks will be moved here.*

---

## Blockers / Notes

### Backend API Dependency
- Frontend development can proceed with mock data
- Full integration requires backend API to be running
- NDJSON streaming endpoint is critical for real-time updates

### Font Loading
- Geist fonts need to be loaded from Vercel CDN or bundled locally
- Fallback stack: `"Geist Mono", "SF Mono", "Cascadia Code", "Fira Code", monospace`

### DAG Visualization Library
- Consider using D3.js, vis.js, or a lighter alternative like Dagre
- Performance critical for graphs with 100+ nodes

### Framework Decision (from spec)
- Framework not specified - candidates: React, Svelte, SolidJS, or vanilla TS
- Recommendation: **React** with TypeScript
  - Large ecosystem for DAG visualization
  - Good TypeBox integration
  - Mature virtual scrolling libraries (react-window, react-virtuoso)
  - Team likely familiar with React patterns

### Environment Variables
```
VITE_API_URL=http://localhost:3001
```

---

*When every task is finished, add a standalone line containing exactly `ALL TASKS COMPLETE` (nothing else on that line) to signal the loop to stop.*
